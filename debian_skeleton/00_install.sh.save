#!/usr/bin/env bash
# 00_install.sh – White Venom / SKELL baseline bootstrap
# Fázisok:
#   0.00 – Environment sterilization
#   0.15 – Network + kernel/fs lockdown (sysctl)
#   1.0  – GRUB env tool + kernelopts baseline
#   2.0  – APT toolchain + memguard deps + security baseline
#   3.0  – ldconfig sanity
#   4.0  – Baseline dirs
#   5.0  – Canary

set -euo pipefail

# ---------------------------------------------------------------------------
# 0.00 – Environment sterilization (prevent env-based root compromise)
# ---------------------------------------------------------------------------

# Fix PATH – no user paths, no injection
export PATH="/usr/sbin:/usr/bin:/sbin:/bin"

# Reset IFS to safe defaults
export IFS=$' \t\n'

# Drop dangerous LD_* vectors
unset LD_PRELOAD
unset LD_LIBRARY_PATH
unset LD_AUDIT
unset LD_DEBUG
unset LD_DEBUG_OUTPUT
unset LD_RUN_PATH

# Drop Python/Ruby/Perl path hijacks
unset PYTHONPATH
unset PYTHONHOME
unset RUBYLIB
unset PERL5LIB
unset PERLLIB
unset PERL5OPT

# Drop Go/Node environment poisoning
unset GOPATH
unset GOMODCACHE
unset NODE_PATH

# Drop Git/SVN injection vectors
unset GIT_CONFIG
unset GIT_CONFIG_GLOBAL
unset GIT_CONFIG_SYSTEM

# Remove exported bash functions (BASH_FUNC_*)
for var in $(env | grep -E '^BASH_FUNC_.*%%=' | cut -d= -f1); do
    unset "$var"
done

# Prevent locale / format-string trükkök
export LANG=C
export LC_ALL=C

SCRIPT_NAME="00_INSTALL"

log() {
    local level="$1"; shift
    local msg="$*"
    printf "%s [%s] %s\n" "$(date +"%Y-%m-%d %H:%M:%S")" "$SCRIPT_NAME/$level" "$msg"
}

# ---------------------------------------------------------------------------
# 0.0 – Root check
# ---------------------------------------------------------------------------
if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    log "FATAL" "Root required."
    exit 1
fi

# ---------------------------------------------------------------------------
# 0.1 – Mode parsing
# ---------------------------------------------------------------------------
MODE="${1:---apply}"

case "$MODE" in
    --apply)   DRY_RUN=0 ;;
    --dry-run) DRY_RUN=1 ;;
    *)
        log "FATAL" "Unknown mode: $MODE"
        exit 1
        ;;
esac

run() {
    if [[ "$DRY_RUN" -eq 1 ]]; then
        log "DRY" "$*"
    else
        log "ACTION" "$*"
        "$@"
    fi
}

log "INFO" "Mode: $MODE"

# ---------------------------------------------------------------------------
# 0.15 – Bootstrap Network + Kernel/FS Lockdown
# ---------------------------------------------------------------------------
log "INFO" "Bootstrap network + kernel/fs lockdown..."

NET_SYSCTL_FILE="/etc/sysctl.d/00_whitevenom_bootstrap.conf"

if [[ "$DRY_RUN" -eq 1 ]]; then
    log "DRY" "Would write $NET_SYSCTL_FILE with IPv4 + fs + kernel lockdown sysctls"
    log "DRY" "Would run: sysctl --system"
else
    # Symlink védelem: ne tudjon /etc/passwd stb.-re mutatni
    if [[ -e "$NET_SYSCTL_FILE" && -L "$NET_SYSCTL_FILE" ]]; then
        log "FATAL" "Sysctl target is symlink: $NET_SYSCTL_FILE"
        exit 1
    fi

    cat > "$NET_SYSCTL_FILE" << 'EOF'
# White Venom – Bootstrap IPv4 + kernel/fs hardening lockdown

# --- IPv4 routing / redirect / spoofing ---
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0

net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0

net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0

# Loopback bypass protection
net.ipv4.conf.all.accept_local = 0
net.ipv4.conf.default.accept_local = 0

# Strict anti-spoofing
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# Stable routing behaviour while IPv4 still active
net.ipv4.conf.all.shared_media = 
net.ipv4.conf.default.shared_media = 0

# --- Filesystem local-priv-esc shields ---
fs.protected_symlinks = 1
fs.protected_hardlinks = 1
fs.protected_fifos = 1
fs.protected_regular = 1

# --- Kernel info-leak / debug surface ---
kernel.kptr_restrict = 2
kernel.dmesg_restrict = 1

# --- Yama ptrace baseline (Debian Trixie: /proc/sys/kernel/yama/ptrace_scope) ---
kernel.yama.ptrace_scope = 1

# --- BPF exploitation surface ---
kernel.unprivileged_bpf_disabled = 1
EOF

    run sysctl --system
fi

# ---------------------------------------------------------------------------
# 0.3 – SKELL environment (optional)
# ---------------------------------------------------------------------------
SKELL_ENV_FILE="${SKELL_ENV_FILE:-/etc/skell/skell.env}"

if [[ -f "$SKELL_ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$SKELL_ENV_FILE"
    log "INFO" "SKELL environment loaded."
fi

# ---------------------------------------------------------------------------
# 1.0 – GRUB env tool + kernelopts baseline
# ---------------------------------------------------------------------------
log "INFO" "GRUB environment bootstrap..."

GRUBENV_CMD=""

if command -v grub-editenv >/dev/null 2>&1; then
    GRUBENV_CMD="grub-editenv"
elif command -v grub2-editenv >/dev/null 2>&1; then
    GRUBENV_CMD="grub2-editenv"
else
    # nincs grub env tool → telepítjük
    if [[ "$DRY_RUN" -eq 1 ]]; then
        log "DRY" "Would run: apt update -y"
        log "DRY" "Would run: apt install -y --no-install-recommends grub-common grub2-common"
    else
        run apt update -y
        run apt install -y --no-install-recommends grub-common grub2-common
    fi
fi

# Telepítés után újradetektálás
if command -v grub-editenv >/dev/null 2>&1; then
    GRUBENV_CMD="grub-editenv"
elif command -v grub2-editenv >/dev/null 2>&1; then
    GRUBENV_CMD="grub2-editenv"
else
    log "FATAL" "No grub-editenv/grub2-editenv found even after install."
    exit 1
fi

log "INFO" "GRUB env tool: $GRUBENV_CMD"

ensure_kernelopts() {
    local existing current_cmdline

    if [[ "$DRY_RUN" -eq 1 ]]; then
        log "DRY" "Would check kernelopts in grubenv and initialize baseline if missing."
        return 0
    fi

    existing="$($GRUBENV_CMD - list 2>/dev/null | grep '^kernelopts=' || true)"

    if [[ -n "$existing" ]]; then
        log "INFO" "kernelopts already present in grubenv → leaving as-is."
        return 0
    fi

    if [[ -r /proc/cmdline ]]; then
        current_cmdline="$(cat /proc/cmdline 2>/dev/null || true)"
    else
        current_cmdline=""
    fi

    if [[ -z "$current_cmdline" ]]; then
        log "WARN" "Could not read /proc/cmdline – kernelopts baseline will not be initialized."
        return 0
    fi

    run "$GRUBENV_CMD" - set "kernelopts=$current_cmdline"
    log "INFO" "kernelopts baseline initialized from /proc/cmdline."
}

ensure_kernelopts

# ---------------------------------------------------------------------------
# 2.0 – APT update + toolchain + memguard deps + security baseline
# ---------------------------------------------------------------------------
run apt update -y

ESSENTIAL_PKGS=(
    build-essential
    gcc
    make
    git
    curl
    wget
    vim-nox
    ca-certificates
    gnupg
    pkg-config
)

MEMGUARD_DEPS=(
    linux-headers-$(uname -r)
    libelf-dev
)

SECURITY_BASE_PKGS=(
    auditd
    apparmor
    apparmor-utils
)

install_packages() {
    local pkgs=("$@")
    local line
    line=$(printf "%s " "${pkgs[@]}")
    run apt install -y --no-install-recommends $line
}

install_packages "${ESSENTIAL_PKGS[@]}"
install_packages "${MEMGUARD_DEPS[@]}"
install_packages "${SECURITY_BASE_PKGS[@]}"

# ---------------------------------------------------------------------------
# 3.0 – ldconfig sanity check
# ---------------------------------------------------------------------------
LD_LOG="/var/log/whitevenom_ld_writable.log"

ld_paths_sanity_check() {
    log "INFO" "ldconfig sanity..."

    local lib_paths
    lib_paths=$(ldconfig -v 2>/dev/null | awk -F':' '/:$/ {print $1}')

    : > "$LD_LOG" 2>/dev/null || true

    while IFS= read -r path; do
        [[ -z "$path" || ! -d "$path" ]] && continue
        run find "$path" -maxdepth 1 -type f -perm -0002 -print >> "$LD_LOG" || true
    done <<< "$lib_paths"

    if [[ -s "$LD_LOG" ]]; then
        log "WARN" "World-writable libs detected. See: $LD_LOG"
    else
        log "INFO" "ldconfig OK"
    fi
}

ld_paths_sanity_check

# ---------------------------------------------------------------------------
# 4.0 – Baseline dirs
# ---------------------------------------------------------------------------
BASE_BACKUP_DIR="/var/backups/skell_backups"
BASE_LOG_DIR="/var/log/whitevenom"
BASE_TMP_DIR="/var/tmp/whitevenom"

for d in "$BASE_BACKUP_DIR" "$BASE_LOG_DIR" "$BASE_TMP_DIR"; do
    if [[ ! -d "$d" ]]; then
        run mkdir -p "$d"
        run chmod 700 "$d"
    fi
done

# ---------------------------------------------------------------------------
# 5.0 – Canary marker
# ---------------------------------------------------------------------------
CANARY_FILE="/etc/whitevenom_canary"

if [[ ! -f "$CANARY_FILE" ]]; then
    if [[ "$DRY_RUN" -eq 0 ]]; then
        echo "WhiteVenom baseline initialized: $(date -Iseconds)" > "$CANARY_FILE"
        chmod 600 "$CANARY_FILE"
    else
        log "DRY" "Create $CANARY_FILE"
    fi
fi

# ---------------------------------------------------------------------------
# END
# ---------------------------------------------------------------------------
log "INFO" "Mode: $MODE"
log "INFO" "GRUB env tool: $GRUBENV_CMD"
log "INFO" "Essentials + memguard deps installed"
log "INFO" "Baseline dirs ready"
log "INFO" "LD sanity log: $LD_LOG"
log "INFO" "00_install complete."
log "INFO" "END."

exit 0
